---
title: "TypeScriptのエラーハンドリング戦略 - Result型と例外の実践的な使い分け"
emoji: "👋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## TypeScriptのエラーハンドリングの現状

### TypeScriptの型安全性とエラーハンドリングのギャップ

JavaScriptのエラーハンドリングはtry-catchが基本ですが、TypeScriptでも型安全性が十分に保証されていません。

```typescript
// この関数がthrowするかどうか、型からは分からない
function getUser(id: string): User {
  if (!db.connected) {
    throw new Error('DB not connected')
  }
  return db.query(...)
}

// catchの型はunknown
try {
  const user = getUser('123')
} catch (error) {
  // error の型は unknown
  // どんなエラーが発生するか型レベルでは分からない
}
```

主な問題点：

- throw可能な関数も型シグネチャに表れない
- catchの型は`unknown`で、エラーの種類が判別できない
- エラーハンドリングの漏れをコンパイル時に検出できない

### Result型への関心の高まり

RustやHaskellなど、Result型（Either型）を持つ言語の影響で、TypeScriptでも型安全なエラーハンドリングへの関心が高まっています。

**Rust**:

```rust
// Result<T, E>型でエラーの可能性が明示される
fn get_user(id: &str) -> Result<User, UserNotFoundError> {
    // ...
}
```

**Haskell**:

```haskell
-- Either型でエラーを値として扱う
getUser :: String -> Either UserNotFoundError User
```

TypeScriptでもResult型ライブラリが登場：

- **fp-ts**: Haskellなどの関数型言語の概念を包括的に実装。Either型（Result型相当）を提供するが、学習コストが高い
- **byethrow**: Result型に特化したシンプルなライブラリ
- **Effect**: 包括的なエフェクトシステム（副作用管理、並行処理等）

### Result型に寄せられる期待

```typescript
import { Result } from '@praha/byethrow'

// エラーの可能性が型シグネチャに表れる
function getUser(id: string): Result<User, UserNotFoundError> {
  const user = db.query(...)
  if (!user) {
    return Result.failure(new UserNotFoundError())
  }
  return Result.success(user)
}

// 使用例
const result = getUser('123')
if (Result.isSuccess(result)) {
  console.log(result.value) // User
} else {
  console.error(result.error) // UserNotFoundError
}
```

Result型への期待：

- **エラーの可能性が型として表現される**
- **エラーハンドリングの漏れをコンパイル時に検出できる**
- **型安全なエラーハンドリングが実現できる**

## Result型への期待と現実のギャップ

### TypeScriptでResult型を使う際の障壁

TypeScriptエコシステムの多くのライブラリはthrowを前提としています。

```typescript
// Drizzle ORM - DB接続エラーでthrow
const orders = db.select().from(orders).iterator()

// AWS SDK - ネットワークエラーでthrow
await s3Client.send(new PutObjectCommand(...))

// Node.js標準ライブラリ - ファイル操作でthrow
fs.readFileSync('/path/to/file')
```

では、try-catchで囲めばいいのでは？

### 個別にtry-catchする方式の問題点

すべてのエラー発生箇所で個別にtry-catchしてカスタムエラーに変換すれば、型情報は保持できます：

```typescript
// ETL処理の例
const processOrders = async (
  orderId: string
): Result<Order, ExtractError | TransformError | LoadError> => {
  let orders: OrderStream

  // Extract: DB接続エラーを個別にハンドリング
  try {
    orders = db.select().from(orders).iterator()
  } catch (error) {
    return Result.failure(new ExtractError('DB接続エラー', { cause: error }))
  }

  let csvStream: CSVStream

  // Transform: データ変換エラーを個別にハンドリング
  try {
    csvStream = await transformToCSV(orders)
  } catch (error) {
    return Result.failure(new TransformError('CSV変換エラー', { cause: error }))
  }

  // Load: S3アップロードエラーを個別にハンドリング
  try {
    await s3Client.send(new PutObjectCommand({ Body: csvStream }))
  } catch (error) {
    return Result.failure(new LoadError('S3アップロードエラー', { cause: error }))
  }

  return Result.success(order)
}
```

この方式なら：

- ✅ Union型（`ExtractError | TransformError | LoadError`）で型安全
- ✅ どのエラーが起きたか型レベルで判別可能
- ✅ エラーの型情報が保持される

しかし、重大な問題があります。

#### 大量のボイラープレート

- すべてのエラー発生箇所でtry-catchが必要
- コードが冗長で読みにくい
- 書き漏らしの可能性がある
- **Situationで期待した「エレガントな型安全性」からは程遠い**

#### 予期しないエラーのハンドリングは意味があるのか？

呼び出し側のコード：

```typescript
const result = await processOrders(orderId)

if (Result.isFailure(result)) {
  if (result.error instanceof TransformError) {
    // これは意味がある：データ変換エラーはビジネスロジックの問題
    logger.error('データ形式が不正です', result.error)
    return { success: false, reason: 'データ変換エラー' }
  }

  if (result.error instanceof ExtractError) {
    // これって意味がある？DB接続エラーで呼び出し側で何ができる？
    // リトライ？でもそれはインフラ層の責務では？
    // ログ？でもそれは共通エラーハンドラがやるべきでは？
    logger.error('DB接続エラー', result.error)
    // 結局、何もできない...
  }

  if (result.error instanceof LoadError) {
    // S3アップロードエラーもアプリケーション層で対処できることは少ない
    // ネットワークエラーやAWSの障害に対して、何をする？
    logger.error('S3アップロードエラー', result.error)
    // 結局、何もできない...
  }
}
```

DB接続エラーやネットワークエラーをResult型で返しても：

- 呼び出し側で意味のあるハンドリングができない
- 結局、共通エラーハンドラーに委譲するだけ
- **労力（大量のtry-catch）に対して、得られるものが無価値ではないか？**

#### すべてのエラーを同列に扱っている

- **TransformError**（データ変換エラー）: 予期される、意味のあるハンドリングができる
- **ExtractError**（DB接続エラー）: 予期しない、アプリケーション層では対処不可能
- **LoadError**（ネットワークエラー）: 予期しない、アプリケーション層では対処不可能

これらを区別する基準がない。

### Rust/Haskellとの違い

Rust/Haskellには「回復可能性」という明確な判断基準があります：

**Rust**:

- 回復可能なエラー → `Result<T, E>`
- 回復不可能なエラー → `panic!`
- 公式ドキュメント: "Returning `Result` is a good default choice when you're defining a function that might fail."

**Haskell**:

- 純粋な部分 → `Either`/`Maybe`
- IO部分 → 例外を許容
- "Don't be afraid to throw runtime exceptions for genuinely exceptional situations"

しかしTypeScriptは前提が異なります：

- 組み込みAPIやライブラリがthrowを前提としている
- 言語レベルでResult型のサポートがない
- エコシステム全体で判断基準が共有されていない

これらの言語と同じ基準をそのまま適用するのは困難です。

## TypeScriptでResult型と例外をどう使い分けるか？

1. **ボイラープレートを減らす方法は？**
   - try-catchを毎回書かずに、エラーをResult型に変換できないか？

2. **意味のあるエラーハンドリングをするには？**
   - どのエラーをResult型で扱うべきか？
   - どのエラーはthrowのまま（共通エラーハンドラーに任せる）でいいのか？
   - 判断基準は？

3. **TypeScriptの現実を踏まえた設計指針は？**
   - throwするライブラリと共存しながら
   - 型安全なエラーハンドリングを実現するには？

## byethrowが示す実践的な判断基準

### 「予期されるエラー」と「予期しないエラー」を区別する

byethrowのベストプラクティスは、Rust/Haskellの考え方をTypeScriptに適用したものです：

#### 予期されるエラー（Anticipated Errors）: Result型で扱う

- **ビジネスロジックの一部として想定されるエラー**
- 呼び出し側が適切にハンドリングできる/すべきエラー
- 例：
  - データのバリデーションエラー
  - リソースが見つからない（404）
  - 権限不足（403）
  - レート制限（429）

#### 予期しないエラー（Unexpected Errors）: throwを許容

- **インフラレベルの問題や、回復不可能なエラー**
- アプリケーションレベルでハンドリングしても意味がないエラー
- 例：
  - データベース接続エラー
  - ネットワークタイムアウト
  - メモリ不足
  - プログラミングバグ（assertion failure）

#### 判断基準の適用例

```typescript
import { Result } from '@praha/byethrow'
import { ErrorFactory } from '@praha/error-factory'

// ❌ Bad: データ変換エラー（予期される）をthrow
const transformToCSV = (data: Data): CSVStream => {
  if (!isValidFormat(data)) {
    throw new Error('Invalid data format') // 予期されるエラーなのにthrow
  }
  return convertToCSV(data)
}

// ✅ Good: 予期されるエラーはResult型で明示
class TransformError extends ErrorFactory({
  name: 'TransformError',
  message: 'データ変換に失敗しました'
}) {}

const transformToCSV = (data: Data): Result<CSVStream, TransformError> => {
  if (!isValidFormat(data)) {
    return Result.failure(new TransformError('データ形式が不正です'))
  }
  return Result.success(convertToCSV(data))
}

// ✅ Good: 予期しないエラー（DB接続エラー等）はthrowを許容
const extractOrders = (): OrderStream => {
  // db.select()はDB接続エラーでthrowするが、それで良い
  // これは予期しないエラーで、アプリケーションレベルでは回復不可能
  return db.select().from(orders).iterator()
}
```

### Result.try()でthrowとResult型の境界を管理

`Result.try()`を使うことで、throwする可能性がある処理をResult型に変換し、ボイラープレートを削減できます。

#### Extract層の実装例

```typescript
import { R } from '@praha/byethrow'
import { ErrorFactory } from '@praha/error-factory'

class ExtractOrdersError extends ErrorFactory({
  name: 'ExtractOrdersError',
  message: '注文情報の抽出に失敗しました'
}) {}

// R.try()で境界を管理
export const extractOrders = R.try({
  try: (): OrderRowStream => {
    // Drizzle ORMの処理
    // DB接続エラーが発生したらthrowされる（予期しないエラー）
    const productNamesSubQuery = a1Database()
      .select({
        orderId: a1Database.schema.orderDetails.orderId,
        productNames: sql<string>`GROUP_CONCAT(${a1Database.schema.products.productName} SEPARATOR '、')`,
      })
      .from(a1Database.schema.orderDetails)
      .innerJoin(
        a1Database.schema.products,
        eq(a1Database.schema.products.id, a1Database.schema.orderDetails.productId),
      )
      .groupBy(a1Database.schema.orderDetails.orderId)
      .as('product_names_list')

    return a1Database()
      .select({
        orderId: a1Database.schema.orders.id,
        accountId: a1Database.schema.orders.accountId,
        productNames: productNamesSubQuery.productNames,
        // ... 他のカラム
      })
      .from(a1Database.schema.orders)
      .innerJoin(productNamesSubQuery, ...)
      .iterator()
  },
  catch: (error) => {
    // 予期しないエラー（DB接続エラー等）をキャッチして
    // カスタムエラーに変換
    return new ExtractOrdersError({ cause: error })
  },
})
```

**ポイント**:

- try-catchを個別に書く必要がない
- throwする可能性がある処理（DB操作）をResult型に変換
- 元のエラーは`cause`プロパティで保持される

#### Transform層の実装例

```typescript
class TransformOrdersToCSVError extends ErrorFactory({
  name: 'TransformOrdersToCSVError',
  message: '注文データのCSV変換に失敗しました'
}) {}

export const transformOrdersToCSV = R.try({
  try: (orderRowStream: OrderRowStream): OrderCSVStream => {
    // データ変換処理
    // ここでもthrowの可能性がある（予期しないエラー：メモリ不足等）
    const formattedRowStream = formatOrderRowStream(orderRowStream)
    const csvStream = rowStreamToCSVStream(formattedRowStream)

    return csvStream
  },
  catch: (error) => {
    return new TransformOrdersToCSVError({ cause: error })
  },
})
```

#### Workflow全体での統合

```typescript
export const etlOrders = async (now: Date) => {
  return await R.pipe(
    R.do(),
    R.andThen(() =>
      extractOrders(), // Result<OrderRowStream, ExtractOrdersError>
    ),
    R.andThen((orderStream) =>
      transformOrdersToCSV(orderStream), // Result<CSVStream, TransformOrdersToCSVError>
    ),
    R.andThen((csvStream) =>
      replaceOrdersCSV({ csvStream, fileName }), // Result<void, ReplaceOrdersCSVError>
    ),
  )
}
```

**Result.try()の利点**:

- 個別のtry-catchが不要（ボイラープレート削減）
- throwとResult型の境界を明確に管理
- 予期しないエラーをキャッチしてカスタムエラーに変換
- パイプラインで関数を合成できる

### 4-3. カスタムエラーで型安全なエラーハンドリング

`@praha/error-factory`を使うと、カスタムエラーを簡単に定義できます：

```typescript
import { ErrorFactory } from '@praha/error-factory'

// エラークラスを定義
class OrderNotFoundError extends ErrorFactory({
  name: 'OrderNotFoundError',
  message: '注文が見つかりません'
}) {}

class InsufficientStockError extends ErrorFactory({
  name: 'InsufficientStockError',
  message: '在庫が不足しています'
}) {}

// Union型でエラーを型安全に扱う
const processOrder = (
  orderId: string,
  quantity: number
): Result<Order, OrderNotFoundError | InsufficientStockError> => {
  const order = findOrder(orderId)
  if (!order) {
    return Result.failure(new OrderNotFoundError())
  }

  if (order.stock < quantity) {
    return Result.failure(new InsufficientStockError())
  }

  // DB更新は失敗したらthrowする（予期しないエラー）
  db.update(order)
  return Result.success(order)
}

// 使用例
const result = processOrder(orderId, 5)
if (Result.isFailure(result)) {
  // result.error の型は OrderNotFoundError | InsufficientStockError
  console.error(result.error.name) // 型安全にエラー名にアクセス
  console.error(result.error.cause) // 元のエラーも参照可能
}
```

**カスタムエラーの利点**:

- 自動的にスタックトレースを取得
- `cause`オプションでエラーチェーンをサポート
- 構造化された文脈情報を提供
- Union型で複数のエラーケースを型安全に扱える

### 4-4. パターンマッチングで複数のエラーを網羅的に処理

Union型のエラーを`ts-pattern`で網羅的にハンドリングできます：

```typescript
import { match } from 'ts-pattern'

const result = processOrder(orderId, quantity)

const message = match(result)
  .with({ type: 'Success' }, ({ value }) => {
    return `注文処理が完了しました（注文ID: ${value.id}）`
  })
  .with({ type: 'Failure', error: { name: 'OrderNotFoundError' } }, () => {
    return '指定された注文が見つかりません'
  })
  .with({ type: 'Failure', error: { name: 'InsufficientStockError' } }, () => {
    return '在庫が不足しているため処理できません'
  })
  .exhaustive() // すべてのケースを処理していることを型レベルで保証

console.log(message)
```

**パターンマッチングの利点**:

- すべてのエラーケースを網羅的に処理
- `.exhaustive()`で処理漏れを型レベルで検出
- 可読性の高いエラーハンドリング
- discriminated unionとの相性が良い

---

## 5. まとめ：TypeScriptでのResult型設計指針

### 判断基準：予期されるエラーか、予期しないエラーか

**予期されるエラー**（ビジネスロジック）→ Result型

- バリデーションエラー
- リソースが見つからない
- 権限不足
- レート制限
- 呼び出し側が適切にハンドリングできる/すべきエラー

**予期しないエラー**（インフラ問題）→ throwを許容

- データベース接続エラー
- ネットワークタイムアウト
- メモリ不足
- プログラミングバグ
- アプリケーションレベルでは回復不可能なエラー

### 実装パターン

1. **Result.try()で境界を管理**
   - throwとResult型を共存させる
   - 予期しないエラーをキャッチしてResult型に変換
   - ボイラープレートを削減

2. **カスタムエラーで型安全性を確保**
   - エラーの種類を型として表現
   - Union型で複数のエラーケースを扱う
   - `@praha/error-factory`で簡単に定義

3. **パターンマッチングで網羅的に処理**
   - すべてのエラーケースを型レベルで保証
   - `.exhaustive()`で処理漏れを防ぐ
   - 可読性の高いエラーハンドリング

### この基準はRust/Haskellのベストプラクティスと一致

- **Rust**: Result（回復可能）+ panic!（回復不可能）
- **Haskell**: Either/Maybe（純粋部分）+ 例外（IO部分）
- **TypeScript + byethrow**: Result型（予期される）+ throw（予期しない）

### byethrowの提供価値

- シンプルなResult型実装
- 明確な判断基準（Anticipated vs Unexpected）
- TypeScriptエコシステムとの親和性（throwとの共存を前提）
- 実践的なコード例とベストプラクティス

---

## 参考リンク

- [byethrow - GitHub](https://github.com/praha-inc/byethrow)
- [byethrow - Best Practices: Result vs Throw](https://praha-inc.github.io/byethrow/guide/best-practices/result-vs-throw)
- [byethrow - Best Practices: Custom Error](https://praha-inc.github.io/byethrow/guide/best-practices/custom-error)
- [byethrow - Best Practices: Pattern Matching](https://praha-inc.github.io/byethrow/guide/best-practices/pattern-matching)
- [The Rust Programming Language - Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [Haskell Wiki - Error vs Exception](https://wiki.haskell.org/Error_vs._Exception)

