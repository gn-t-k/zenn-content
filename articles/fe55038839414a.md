---
title: "使いやすいフォームを実装するための工夫（例）登録フォーム"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["アクセシビリティ", "chakraui", "reacthookform"]
published: false
publication_name: "praha"
---

フォームはwebアプリケーションのもっとも重要な要素の1つであり、フォームの使いやすさはwebアプリケーションの使いやすさに直結します。Chakra UIとReact Hook Formを使った実装を例に、使いやすいフォームを実装するための工夫を紹介します。

## 実装するフォーム

3つのフィールドと1つの送信ボタンを含む登録フォームです。

![3つのフィールドと1つの送信ボタンを含む登録フォーム](/images/articles/fe55038839414a/image01.png)

実装は以下のようになっています。

:::details register-form.tsx

```tsx
import {
  Button,
  Container,
  FormControl,
  FormErrorMessage,
  FormLabel,
  Heading,
  Input,
  Stack,
  useToast,
} from "@chakra-ui/react";
import { useCallback, useEffect } from "react";

import type { MutationState } from "@/utils/mutation-state";

import { useRegisterForm } from "./use-register-form";

import type { RegisterField } from "./use-register-form";
import type { FC } from "react";
import type { SubmitHandler } from "react-hook-form";

type Props = {
  register: Register;
  registerStatus: MutationState;
};
export const RegisterForm: FC<Props> = (props) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useRegisterForm();
  const toast = useToast();
  const onSubmit = useCallback<SubmitHandler<RegisterField>>(
    (fieldValues) => {
      props.register({
        name: fieldValues.name,
        email: fieldValues.email,
        password: fieldValues.password,
      });
    },
    [props]
  );

  useEffect(() => {
    switch (props.registerStatus) {
      case "success":
        toast({
          title: "登録しました",
          status: "success",
          isClosable: true,
        });
        return;
      case "error":
        toast({
          title: "登録に失敗しました",
          status: "error",
          isClosable: true,
        });
        return;
    }
  }, [props.registerStatus, toast]);

  return (
    <Container>
      <Stack direction="column" gap={8}>
        <Heading>登録フォーム</Heading>
        <form onSubmit={handleSubmit(onSubmit)}>
          <Stack direction="column" gap={4}>
            <FormControl isInvalid={!!errors.name}>
              <FormLabel htmlFor="name">名前</FormLabel>
              <Input type="text" id="name" {...register("name")} />
              {!!errors.name && (
                <FormErrorMessage>{errors.name.message}</FormErrorMessage>
              )}
            </FormControl>
            <FormControl isInvalid={!!errors.email}>
              <FormLabel htmlFor="email">メールアドレス</FormLabel>
              <Input type="email" id="email" {...register("email")} />
              {!!errors.email && (
                <FormErrorMessage>{errors.email.message}</FormErrorMessage>
              )}
            </FormControl>
            <FormControl isInvalid={!!errors.password}>
              <FormLabel htmlFor="password">パスワード</FormLabel>
              <Input type="password" id="password" {...register("password")} />
              {!!errors.password && (
                <FormErrorMessage>{errors.password.message}</FormErrorMessage>
              )}
            </FormControl>
            <Button
              type="submit"
              isLoading={props.registerStatus === "loading"}
              isDisabled={props.registerStatus === "loading"}
            >
              登録する
            </Button>
          </Stack>
        </form>
      </Stack>
    </Container>
  );
};
```

本筋と関係ないので適当ですが、`Register`や`MutationState`は以下のような型になっています。

```typescript
type Register = (props: {
  name: string;
  email: string;
  password: string;
}) => void;

export type MutationState = "idle" | "loading" | "success" | "error";
```

:::

::: details use-register-form.ts

```typescript
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

import { useForm } from "@/libs/react-hook-form/use-form";

import type { UseFormReturn } from "react-hook-form";

const registerFieldSchema = z.object({
  name: z.string().min(1, "名前を入力してください"),
  email: z
    .string()
    .min(1, "メールアドレスを入力してください")
    .email("メールアドレスの形式で入力してください"),
  password: z.string().min(8, "パスワードは8文字以上で入力してください"),
});
export type RegisterField = z.infer<typeof registerFieldSchema>;

type UseRegisterForm = (
  defaultValues?: RegisterField
) => UseFormReturn<RegisterField>;
export const useRegisterForm: UseRegisterForm = (defaultValues) => {
  return useForm<RegisterField>({
    resolver: zodResolver(registerFieldSchema),
    defaultValues: defaultValues ?? {
      name: "",
      email: "",
      password: "",
    },
  });
};
```

:::

実際のAPIがなくても、Storybookで再現できます。

::: details register-form.stories.tsx

```tsx
import { action } from "@storybook/addon-actions";
import { useState } from "react";

import type { MutationState } from "@/utils/mutation-state";
import { sleep } from "@/utils/sleep";

import { RegisterForm } from "./register-form";

import type { ComponentMeta, ComponentStoryObj } from "@storybook/react";
import type { ComponentProps, FC } from "react";

type Meta = ComponentMeta<typeof RegisterForm>;
type Props = ComponentProps<typeof RegisterForm>;
type Story = ComponentStoryObj<typeof RegisterForm>;

const componentMeta: Meta = {
  component: RegisterForm,
};
export default componentMeta;

const Wrapper: FC<Partial<Props>> = (props) => {
  const [registerStatus, setRegisterStatus] = useState<MutationState>("idle");
  const register: Props["register"] = () => {
    (async (): Promise<void> => {
      setRegisterStatus("loading");
      await sleep(1000);
      action("register");
      setRegisterStatus("success");
    })();
  };
  const args: Props = {
    register: props.register ?? register,
    registerStatus: props.registerStatus ?? registerStatus,
  };

  return <RegisterForm {...args} />;
};

const Template: Story = {
  render: (props: Partial<Props>) => {
    return <Wrapper {...props} />;
  },
};

export const Default: Story = {
  ...Template,
};
```

:::

## 工夫

### ラベル

### プレースホルダー

### フィールドのスタイリング

### フィールド特有の工夫

### submitボタン

### バリデーション

### フィードバック

## 参考
