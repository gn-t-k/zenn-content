---
title: "フロントエンドにテストを書きつつ開発速度を保つためにやったこと"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

フロントエンドの開発において、テストコードを充実させることはいいことづくめのように思えます。

- 機能が壊れていないことを確認しながらプロダクションコードを変更できる
  - バグの発生に気づきやすくなる
  - 省ける動作確認が増え、開発速度が向上する
- テストを書きやすいように工夫してプロダクションコードを書くようになり、結果的にコンポーネントの設計やアクセシビリティを向上させることができる

とはいえ、フロントエンドのテストコードを充実させるにはかなり工数が必要です。また、テストの書き方によってはメンテナンスコストもかかり、最悪の場合壊れっぱなしで放置されがちです。

プロダクトの新規開発にあたって0からフロントエンドの設計・開発環境構築をする機会があったので、フロントエンドのテストについて調査して内容を整理しました。

## 前提

React/TypeScriptです。

## Jest、Storybook、testing-library、MSWを活用する

単体テストの記述パターンとしてAAAパターンというものが知られています。AAAはArrange（準備）/Act（実行）/Assert（確認）の頭文字を並べたものです。フロントエンドのテストにおいては、Storybookを[CSF3.0](https://storybook.js.org/blog/component-story-format-3-0/)のフォーマットで記述し（Arrange）、Jestのテストケースの中でコンポーネントをrender（Act）→結果を検証（Assert）することでAAAパターンのテストコードを書くことができます。

@[card](https://storybook.js.org/)
@[card](https://jestjs.io/ja/)

StorybookをCSF3.0のフォーマットで記述する理由の1つとして、play関数があります。play関数内でtesting-libraryを使ってユーザーがアプリケーション上で行う操作を再現することで、ユーザーの操作を他のテスト等で再利用可能な資材として管理できます。

@[card](https://testing-library.com/)

APIなどの外部データの取得をテストで再現するのは、MSWによるモックが便利です。MSWは、リクエストをインターセプトして任意のレスポンスを返すことができます。MSW無しでモックしようとすると、コンポーネントのテストをしたいがために無理やりなコンポーネント分割したり、しんどいprops drillingを実装したりする必要がでてくることがあります（経験談）。[MSW Storybook Addon](https://storybook.js.org/addons/msw-storybook-addon)など、MSWをStorybookでうまく使うためのaddonなどもあります。

@[card](https://mswjs.io/)

これらのライブラリを具体的にどうやって組み合わせるのかについてですが、今回のプロジェクトでは、Storybookのpreview.jsでMSWの設定をし、それをjest.setup.tsでも利用するという形で設定しています。

```tsx
// preview.js
import { ChakraProvider } from "@chakra-ui/react";
import { initialize, mswDecorator } from "msw-storybook-addon";
import { createClient, Provider } from "urql";
import fetch from "cross-fetch";

// Initialize MSW
initialize();

const client = createClient({
  url: process.env.MOCK_ENDPOINT,
  fetch,
});

export const decorators = [
  (Story) => (
    <Provider value={client}>
      <ChakraProvider>
        <Story />
      </ChakraProvider>
    </Provider>
  ),
  mswDecorator,
];
```

```typescript
// jest.setup.ts
import { setGlobalConfig } from "@storybook/testing-react";

import * as globalStorybookConfig from "./.storybook/preview";

import "@testing-library/jest-dom";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
setGlobalConfig(globalStorybookConfig as any);
```

詳細な説明は割愛しますが、Reactコンポーネントの実装とstorybook、テストは以下のようになります。[初めてのGraphQL](https://www.oreilly.co.jp/books/9784873118932/)にサンプルとして出てくる「スキー場の職員がコースとかリフトの状態を確認・管理するためのGraphQL API」の一部をGUIアプリケーションとして実装したものです。

```tsx
export const Details: FC<DetailsProps> = (props) => {
  const [query] = useGetLiftDetailsQuery({
    variables: {
      id: props.id,
    },
  });
  const [mutationState, mutate] = useSetLiftStatusMutation();
  const { isOpen, onOpen, onClose } = useDisclosure();
  const setStatus = useCallback<ComponentProps<typeof LiftForm>["setStatus"]>(
    (status) => {
      (async (): Promise<void> => {
        await mutate({
          id: props.id,
          status,
        });
        onClose();
      })();
    },
    [mutate, onClose, props.id]
  );

  if (query.fetching) {
    return <Loading description="リフトのデータを取得しています" />;
  }

  if (query.error || !query.data) {
    return <p>リフトのデータの取得に失敗しました</p>;
  }

  return (
    <Stack direction="column">
      <Heading size="md">名前</Heading>
      <Text>{query.data.Lift.name}</Text>
      <Heading size="md">ステータス</Heading>
      <Stack direction="row">
        {mutationState.fetching ? (
          <Spinner />
        ) : (
          <Text>{query.data.Lift.status ?? "UNKNOWN"}</Text>
        )}
        {query.data.Lift.status === undefined ? (
          <Button isDisabled>ステータスを変更</Button>
        ) : (
          <LiftForm
            defaultValues={{
              status: query.data.Lift.status,
            }}
            setStatus={setStatus}
            isOpen={isOpen}
            onOpen={onOpen}
            onClose={onClose}
          />
        )}
      </Stack>
      <Stack direction="column">
        <Heading size="md">行き先</Heading>
        {query.data.Lift.trailAccess.map((trail) => {
          return <Text key={trail.id}>{trail.name}</Text>;
        })}
      </Stack>
    </Stack>
  );
};
```

```tsx
import { screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { LiftStatus } from "@/libs/graphql-codegen/types";

import {
  mockGetLiftDetailsQueryMsw,
  mockSetLiftStatusMutationMsw,
} from "@/features/lift/details/index.generated";

import Page from "./index.page";

import type { ComponentMeta, ComponentStoryObj } from "@storybook/react";
import type { ComponentProps, FC } from "react";

type Meta = ComponentMeta<typeof Page>;
type Props = ComponentProps<typeof Page>;
type Story = ComponentStoryObj<typeof Page>;

const componentMeta: Meta = {
  component: Page,
};
export default componentMeta;

const Wrapper: FC<Partial<Props>> = (props) => {
  const defaultProps: Props = {
    id: "id-l-1",
  };

  return (
    <Page
      {...{
        ...defaultProps,
        ...props,
      }}
    />
  );
};

const Template: Story = {
  render: (props: Partial<Props>) => {
    return <Wrapper {...props} />;
  },
  parameters: {
    msw: {
      handlers: [
        mockGetLiftDetailsQueryMsw((req, res, ctx) => {
          return res(
            ctx.data({
              Lift: {
                id: "id-l-1",
                name: "リフト1",
                status: LiftStatus.Open,
                trailAccess: [
                  {
                    id: "id-t-1",
                    name: "コース1",
                  },
                  {
                    id: "id-t-2",
                    name: "コース2",
                  },
                ],
              },
            })
          );
        }),
        mockSetLiftStatusMutationMsw((req, res, ctx) => {
          return res(
            ctx.data({
              setLiftStatus: {
                id: "id-l-1",
              },
            })
          );
        }),
      ],
    },
  },
};

export const Default: Story = {
  ...Template,
};

export const ステータス変更ポップオーバーを開く: Story = {
  ...Template,
  play: async () => {
    const openPopoverButton = await screen.findByRole("button", {
      name: "ステータスを変更",
    });

    await userEvent.click(openPopoverButton);
  },
};

export const ステータスをClosedに変更して更新: Story = {
  ...Template,
  play: async () => {
    const openPopoverButton = await screen.findByRole("button", {
      name: "ステータスを変更",
    });
    await userEvent.click(openPopoverButton);

    const radioInputClosed = await screen.findByRole("radio", {
      name: "CLOSED",
    });
    await userEvent.click(radioInputClosed);

    const submitButton = screen.getByRole("button", {
      name: "更新",
    });
    await userEvent.click(submitButton);
  },
};

export const ステータスをClosedに変更して閉じる: Story = {
  ...Template,
  play: async () => {
    const openPopoverButton = await screen.findByRole("button", {
      name: "ステータスを変更",
    });
    await userEvent.click(openPopoverButton);

    const radioInputClosed = await screen.findByRole("radio", {
      name: "CLOSED",
    });
    await userEvent.click(radioInputClosed);

    const closeButton = screen.getByRole("button", {
      name: "ステータス変更ポップオーバーを閉じる",
    });
    await userEvent.click(closeButton);
  },
};
```

```tsx
import { composeStories } from "@storybook/testing-react";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import * as stories from "./index.stories";

describe("lift-id", () => {
  const Stories = composeStories(stories);

  describe("初期状態", () => {
    beforeEach(() => {
      render(<Stories.Default />);
    });

    test("リフト詳細を表示できる", async () => {
      const liftName = await screen.findByText("リフト1");
      const trailName1 = await screen.findByText("コース1");
      const trailName2 = await screen.findByText("コース2");

      expect(liftName).toBeInTheDocument();
      expect(trailName1).toBeInTheDocument();
      expect(trailName2).toBeInTheDocument();
    });
  });

  describe("ステータス変更ポップオーバーを開く", () => {
    describe("ステータスをClosedにする", () => {
      describe("更新ボタンをクリック", () => {
        // MEMO: スパイの注入が必要なため、lift-form.test.tsxで実施
        test.todo("ステータスの変更が実行される");
      });

      describe("閉じるボタンをクリック", () => {
        beforeEach(async () => {
          const { container } = render(
            <Stories.ステータスをClosedに変更して閉じる />
          );

          await Stories.ステータスをClosedに変更して閉じる.play({
            canvasElement: container,
          });
        });

        test("フォームの値がリセットされてOPENに戻っている", async () => {
          // 確認のため再度ポップオーバーを開く
          const openPopoverButton = await screen.findByRole("button", {
            name: "ステータスを変更",
          });
          await userEvent.click(openPopoverButton);

          const radioButtonOpen = screen.getByRole("radio", { name: "OPEN" });

          expect(radioButtonOpen).toBeChecked();
        });
      });
    });
  });
});
```

## 自動生成できる部分は自動生成する

Jest、Storybook、testing-library、MSWなどの便利ライブラリがたくさんあるとはいえ、コンポーネントを実装するたびに大量の定型文を書かなければならないのはしんどいです。テストを書くのがめんどくさくて誰もテストを書かなくなった、といった事態を避けるために、自動生成できる部分は自動生成したいものです。

まず、コンポーネントとStorybookとjestの3つのファイルを同時に生成できるスクリプトを[scaffdog](https://scaff.dog/)を使って用意しました。

[用意したmd](https://gist.github.com/gn-t-k/7847b69fd5337c731a12855ad92ada1e)
（markdownの中にmarkdown書くのうまくいかない…）

↑のようなmarkdownを用意して、package.jsonのscriptに`"gen:component": "yarn run scaffdog generate component"`など用意しておけば、`yarn gen:component`コマンドを実行して対話形式でディレクトリの場所や名前などを指定するだけでコンポーネントとStorybookとjestの3つのファイルを同時に生成できるようになります。

次に、MSWのhandlerも自動生成するようにしました。今回のプロジェクトではAPIへリクエストを送信するhooksなどをGraphQL Code Generatorで自動生成するようにしています（テストと関係ないので詳細は省きます）。[@graphql-codegen/typescript-msw](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-msw)というGraphQL Code Generatorのpluginを使用することで、hooksなどといっしょにMSWのhandlerも自動生成してくれるようになります。自動生成されたhandlerがあると、StorybookでMSWをつかってリクエストをモックするとき、リクエストのクエリを書いたりレスポンスの型を指定する手間が省けます。

```typescript
import { mockGeneratedQueryMsw } from "path/to/generated";

// 〜〜

const Template: Story = {
  render: (props: Partial<Props>) => {
    return <Wrapper {...props} />;
  },
  parameters: {
    msw: {
      handlers: [
        // 自動生成されたhandler
        mockGeneratedQueryMsw((req, res, ctx) => {
          return res(
            ctx.data({
              // ここにレスポンスを定義する
            })
          );
        }),
      ],
    },
  },
};
```

### すぐに動作確認できるプレビュー環境を用意する
